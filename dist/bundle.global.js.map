{"version":3,"file":"bundle.global.js","sources":["../src/ratelimit.ts","../src/types.ts","../src/get.ts","../src/update.ts","../src/append.ts","../src/delete.ts","../src/index.ts"],"sourcesContent":["export function callHandler<T>(fn: () => T, retries: number = 16): T {\n  let attempt = 0;\n\n  while (attempt < retries) {\n    try {\n      return fn();\n    } catch (error) {\n      if (\n        error.message.includes(\"429\") ||\n        error.message.includes(\"Quota exceeded for quota metric\")\n      ) {\n        attempt++;\n        const backoffDelay = Math.min(\n          Math.pow(2, attempt) + Math.random() * 1000,\n          64000\n        );\n        Utilities.sleep(backoffDelay);\n      } else {\n        throw error; // Rethrow if it's not a rate limit error\n      }\n    }\n  }\n\n  throw new Error(\"Max retries reached for Google Sheets API call.\");\n}\n","export type GQueryReadOptions = {\n  valueRenderOption?: ValueRenderOption;\n  dateTimeRenderOption?: DateTimeRenderOption;\n};\nexport type GQueryResult = {\n  rows: GQueryRow[];\n  headers: string[];\n};\nexport type GQueryRow = Record<string, any> & {\n  __meta: {\n    rowNum: number;\n    colLength: number;\n  };\n};\nexport enum ValueRenderOption {\n  FORMATTED_VALUE = \"FORMATTED_VALUE\",\n  UNFORMATTED_VALUE = \"UNFORMATTED_VALUE\",\n  FORMULA = \"FORMULA\",\n}\nexport enum DateTimeRenderOption {\n  FORMATTED_STRING = \"FORMATTED_STRING\",\n  SERIAL_NUMBER = \"SERIAL_NUMBER\",\n}\n","import { GQuery, GQueryTable, GQueryTableFactory } from \"./index\";\nimport { callHandler } from \"./ratelimit\";\nimport {\n  GQueryReadOptions,\n  GQueryResult,\n  ValueRenderOption,\n  DateTimeRenderOption,\n  GQueryRow,\n} from \"./types\";\n\nexport function getManyInternal(\n  gquery: GQuery,\n  sheetNames: string[],\n  options?: GQueryReadOptions\n): {\n  [sheetName: string]: GQueryResult;\n} {\n  if (!sheetNames || sheetNames.length === 0) {\n    return {};\n  }\n\n  // Set default options if not provided\n  const valueRenderOption =\n    options?.valueRenderOption || ValueRenderOption.FORMATTED_VALUE;\n  const dateTimeRenderOption =\n    options?.dateTimeRenderOption || DateTimeRenderOption.FORMATTED_STRING;\n\n  const result: { [sheetName: string]: GQueryResult } = {};\n  const headersMap: { [sheetName: string]: string[] } = {};\n\n  // Step 1: Get headers for each sheet (row 1)\n  for (const sheetName of sheetNames) {\n    try {\n      const headerResponse = callHandler(() =>\n        Sheets.Spreadsheets.Values.get(\n          gquery.spreadsheetId,\n          `${sheetName}!1:1`,\n          {\n            valueRenderOption: valueRenderOption,\n            dateTimeRenderOption: dateTimeRenderOption,\n          }\n        )\n      );\n\n      if (\n        !headerResponse ||\n        !headerResponse.values ||\n        headerResponse.values.length === 0\n      ) {\n        // Handle empty sheet or sheet with no headers\n        result[sheetName] = { headers: [], rows: [] };\n        continue;\n      }\n\n      headersMap[sheetName] = headerResponse.values[0].map((header) =>\n        String(header)\n      );\n    } catch (e) {\n      console.error(`Error fetching headers for sheet ${sheetName}:`, e);\n      result[sheetName] = { headers: [], rows: [] };\n    }\n  }\n\n  // Step 2: Get data for sheets that have headers\n  const sheetsToFetch = Object.keys(headersMap).filter(\n    (sheet) => headersMap[sheet].length > 0\n  );\n\n  if (sheetsToFetch.length === 0) {\n    return result;\n  }\n\n  // Also fetch metadata for each sheet to determine data types\n  let sheetMetadata: { [sheetName: string]: { [header: string]: string } } = {};\n\n  try {\n    // Get spreadsheet metadata including sheet tables if available\n    const metadataResponse = callHandler(() =>\n      Sheets.Spreadsheets.get(gquery.spreadsheetId, {\n        fields: \"sheets(properties(title),tables.columnProperties)\",\n      })\n    );\n\n    if (metadataResponse && metadataResponse.sheets) {\n      metadataResponse.sheets.forEach((sheet) => {\n        const sheetName = sheet.properties?.title;\n        if (!sheetName || !sheetsToFetch.includes(sheetName)) return;\n\n        // @ts-expect-error: TypeScript may not recognize the tables property\n        if (sheet.tables && sheet.tables.length > 0) {\n          // Use the first table definition for column properties\n          // @ts-expect-error: TypeScript may not recognize the tables property\n          const table = sheet.tables[0];\n          if (table.columnProperties) {\n            sheetMetadata[sheetName] = {};\n\n            // For each column property, store its data type\n            Object.keys(table.columnProperties).forEach((column) => {\n              const dataType = table.columnProperties[column].dataType;\n              if (dataType) {\n                sheetMetadata[sheetName][column] = dataType;\n              }\n            });\n          }\n        }\n      });\n    }\n  } catch (e) {\n    console.error(\"Error fetching metadata:\", e);\n    // Continue without metadata - types won't be converted\n  }\n\n  // Batch get data for all sheets (just use the sheet name as the range)\n  const dataRanges = sheetsToFetch.map((sheet) => `${sheet}`);\n  const dataResponse = callHandler(() =>\n    Sheets.Spreadsheets.Values.batchGet(gquery.spreadsheetId, {\n      ranges: dataRanges,\n      valueRenderOption: valueRenderOption,\n      dateTimeRenderOption: dateTimeRenderOption,\n    })\n  );\n\n  if (!dataResponse || !dataResponse.valueRanges) {\n    // Return just the headers if we couldn't get any data\n    sheetsToFetch.forEach((sheet) => {\n      result[sheet] = {\n        headers: headersMap[sheet],\n        rows: [],\n      };\n    });\n    return result;\n  }\n\n  // Process each value range from the batch response\n  dataResponse.valueRanges.forEach((valueRange, index) => {\n    const sheetName = sheetsToFetch[index];\n    const headers = headersMap[sheetName];\n\n    if (!valueRange.values || valueRange.values.length === 0) {\n      // Sheet exists but has no data rows\n      result[sheetName] = { headers, rows: [] };\n      return;\n    }\n\n    const rows: GQueryRow[] = [];\n    const columnTypes = sheetMetadata[sheetName] || {};\n\n    // Process data rows\n    valueRange.values.forEach((rowData, rowIndex) => {\n      const row: GQueryRow = {\n        __meta: {\n          rowNum: rowIndex + 2, // +2 because we're starting from index 0 and row 1 is headers\n          colLength: rowData.length,\n        },\n      };\n\n      // First initialize all header fields to empty strings\n      headers.forEach((header) => {\n        row[header] = \"\";\n      });\n\n      // Map each column value to its corresponding header\n      for (let j = 0; j < Math.min(rowData.length, headers.length); j++) {\n        const header = headers[j];\n        let value = rowData[j];\n\n        if (value === null || value === undefined) {\n          continue; // Skip processing but keep the empty string initialized earlier\n        }\n\n        // Apply type conversions based on metadata if available\n        if (columnTypes[header] && value !== \"\") {\n          const dataType = columnTypes[header];\n\n          if (dataType === \"BOOLEAN\") {\n            // Convert to boolean\n            if (typeof value === \"string\") {\n              value = value.toLowerCase() === \"true\";\n            }\n          } else if (dataType === \"DATE_TIME\") {\n            // Convert to Date object\n            try {\n              const dateValue = new Date(value);\n              if (!isNaN(dateValue.getTime())) {\n                value = dateValue;\n              }\n            } catch (e) {\n              // Keep original value if conversion fails\n            }\n          } else if (dataType === \"NUMBER\") {\n            // Convert to number\n            const numValue = Number(value);\n            if (!isNaN(numValue)) {\n              value = numValue;\n            }\n          }\n        } else {\n          // Try automatic type inference for common patterns\n          if (typeof value === \"string\") {\n            // Auto-detect booleans\n            if (\n              value.toLowerCase() === \"true\" ||\n              value.toLowerCase() === \"false\"\n            ) {\n              value = value.toLowerCase() === \"true\";\n            }\n            // Auto-detect dates (simple pattern for dates like MM/DD/YYYY, etc.)\n            else if (\n              /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}(\\s\\d{1,2}:\\d{1,2}(:\\d{1,2})?)?$/.test(\n                value\n              )\n            ) {\n              try {\n                const dateValue = new Date(value);\n                if (!isNaN(dateValue.getTime())) {\n                  value = dateValue;\n                }\n              } catch (e) {\n                // Keep as string if conversion fails\n              }\n            }\n          }\n        }\n\n        row[header] = value;\n      }\n\n      rows.push(row);\n    });\n\n    result[sheetName] = { headers, rows };\n  });\n\n  // Make sure all sheets in headersMap have an entry in result\n  sheetsToFetch.forEach((sheet) => {\n    if (!result[sheet]) {\n      result[sheet] = {\n        headers: headersMap[sheet],\n        rows: [],\n      };\n    }\n  });\n\n  // Convert data types based on metadata if available\n  if (Object.keys(sheetMetadata).length > 0) {\n    Object.keys(result).forEach((sheetName) => {\n      const sheetResult = result[sheetName];\n      const metadata = sheetMetadata[sheetName];\n\n      if (sheetResult && sheetResult.rows && metadata) {\n        sheetResult.rows = sheetResult.rows.map((row) => {\n          const newRow = { ...row };\n\n          Object.keys(metadata).forEach((column) => {\n            const dataType = metadata[column];\n\n            // Convert based on data type\n            if (dataType === \"NUMBER\") {\n              newRow[column] = Number(row[column]);\n            } else if (dataType === \"BOOLEAN\") {\n              newRow[column] = row[column] === \"TRUE\";\n            } else if (dataType === \"DATE\" || dataType === \"DATETIME\") {\n              newRow[column] = new Date(row[column]);\n            }\n            // Add more conversions as needed\n          });\n\n          return newRow;\n        });\n      }\n    });\n  }\n\n  return result;\n}\n\nexport function getInternal(\n  gqueryTableFactory: GQueryTableFactory,\n  options?: GQueryReadOptions\n): GQueryResult {\n  const gqueryTable = gqueryTableFactory.gQueryTable;\n  const gquery = gqueryTable.gquery;\n  // Determine which sheets we need to read from\n  const sheetsToRead = [gqueryTable.sheetName];\n\n  // Add all join sheets\n  if (gqueryTableFactory.joinOption.length > 0) {\n    gqueryTableFactory.joinOption.forEach((join) => {\n      if (!sheetsToRead.includes(join.sheetName)) {\n        sheetsToRead.push(join.sheetName);\n      }\n    });\n  }\n\n  // Read data from all required sheets at once\n  const results = gquery.getMany(sheetsToRead, options);\n\n  // If the main sheet doesn't exist or has no data\n  if (\n    !results[gqueryTable.sheetName] ||\n    results[gqueryTable.sheetName].rows.length === 0\n  ) {\n    return { headers: [], rows: [] };\n  }\n\n  // Get data for the primary table\n  let result = results[gqueryTable.sheetName];\n  let rows = result.rows;\n  let headers = result.headers;\n\n  // Process each join sequentially\n  if (gqueryTableFactory.joinOption.length > 0) {\n    gqueryTableFactory.joinOption.forEach((joinConfig) => {\n      const { sheetName, sheetColumn, joinColumn, columnsToReturn } =\n        joinConfig;\n\n      const joinData = results[sheetName];\n\n      if (!joinData || !joinData.rows || joinData.rows.length === 0) {\n        return; // Skip this join\n      }\n\n      // Create join lookup table\n      const joinMap: Record<string, any[]> = {};\n\n      // Check if the join column exists in the join table\n      const joinHeaders = joinData.headers;\n      if (!joinHeaders.includes(sheetColumn)) {\n        return; // Skip this join\n      }\n\n      joinData.rows.forEach((joinRow) => {\n        const joinKey = String(joinRow[sheetColumn]);\n        if (!joinMap[joinKey]) {\n          joinMap[joinKey] = [];\n        }\n        joinMap[joinKey].push(joinRow);\n      });\n\n      // Perform the join operation\n      rows = rows.map((row) => {\n        const localJoinValue = row[joinColumn];\n        const joinedRows = joinMap[String(localJoinValue)] || [];\n\n        // Create joined row with all join table fields\n        const joinedRow = { ...row };\n\n        joinedRows.forEach((joinRow, index) => {\n          // Determine which columns to include from join\n          const columnsToInclude =\n            columnsToReturn ||\n            Object.keys(joinRow).filter(\n              (key) => key !== \"__meta\" && key !== sheetColumn\n            );\n\n          columnsToInclude.forEach((key) => {\n            if (joinRow.hasOwnProperty(key) && key !== \"__meta\") {\n              // For multiple joined rows, add suffix _1, _2, etc.\n              const suffix = joinedRows.length > 1 ? `_${index + 1}` : \"\";\n              const targetKey = key === sheetColumn ? key : `${key}${suffix}`;\n              joinedRow[targetKey] = joinRow[key];\n            }\n          });\n        });\n\n        return joinedRow;\n      });\n    });\n  }\n\n  // Apply filter if specified\n  if (gqueryTableFactory.filterOption) {\n    rows = rows.filter(gqueryTableFactory.filterOption);\n  }\n\n  // Apply select if specified\n  if (\n    gqueryTableFactory.selectOption &&\n    gqueryTableFactory.selectOption.length > 0\n  ) {\n    // Create a map to track columns from joined tables\n    const joinedColumns = new Set<string>();\n\n    // Collect all columns from joined tables\n    rows.forEach((row) => {\n      Object.keys(row).forEach((key) => {\n        // If the column is not in the original headers, it's from a join\n        if (!headers.includes(key) && key !== \"__meta\") {\n          joinedColumns.add(key);\n        }\n      });\n    });\n\n    // If we have a select option, determine which columns to keep\n    let selectedHeaders: string[];\n\n    // Check if any of the selected headers is \"Model\" or \"Model_Name\"\n    // If we're selecting the join columns, we want to include all related joined fields\n    if (\n      gqueryTableFactory.selectOption.some(\n        (header) =>\n          header === \"Model\" ||\n          header === \"Model_Name\" ||\n          gqueryTableFactory.joinOption.some(\n            (j) => j.joinColumn === header || j.sheetColumn === header\n          )\n      )\n    ) {\n      // Include all join-related columns and the selected columns\n      selectedHeaders = [...gqueryTableFactory.selectOption];\n      joinedColumns.forEach((joinCol) => {\n        selectedHeaders.push(joinCol);\n      });\n    } else {\n      // Otherwise only include explicitly selected columns\n      selectedHeaders = [...gqueryTableFactory.selectOption];\n    }\n\n    // Remove duplicates\n    selectedHeaders = [...new Set(selectedHeaders)];\n\n    // Filter rows to only include selected columns\n    rows = rows.map((row) => {\n      const selectedRow: GQueryRow = {\n        __meta: row.__meta,\n      };\n\n      selectedHeaders.forEach((header) => {\n        if (row.hasOwnProperty(header)) {\n          selectedRow[header] = row[header];\n        }\n      });\n\n      return selectedRow;\n    });\n\n    // Update headers to include both selected and joined columns\n    return {\n      headers: selectedHeaders,\n      rows,\n    };\n  }\n\n  return {\n    headers,\n    rows,\n  };\n}\n\nexport function queryInternal(\n  gqueryTable: GQueryTable,\n  query: string\n): GQueryResult {\n  var sheet = gqueryTable.sheet;\n  var range = sheet.getDataRange();\n  var replaced = query;\n  for (var i = 0; i < range.getLastColumn() - 1; i++) {\n    var rng = sheet.getRange(1, i + 1);\n\n    var name = rng.getValue();\n    var letter = rng.getA1Notation().match(/([A-Z]+)/)[0];\n    replaced = replaced.replaceAll(name, letter);\n  }\n\n  var response = UrlFetchApp.fetch(\n    Utilities.formatString(\n      \"https://docs.google.com/spreadsheets/d/%s/gviz/tq?tq=%s%s%s%s\",\n      sheet.getParent().getId(),\n      encodeURIComponent(replaced),\n      \"&sheet=\" + sheet.getName(),\n      typeof range === \"string\" ? \"&range=\" + range : \"\",\n      \"&headers=1\"\n    ),\n    {\n      headers: {\n        Authorization: \"Bearer \" + ScriptApp.getOAuthToken(),\n      },\n    }\n  );\n\n  var jsonResponse = JSON.parse(\n      response\n        .getContentText()\n        .replace(\"/*O_o*/\\n\", \"\")\n        .replace(/(google\\.visualization\\.Query\\.setResponse\\()|(\\);)/gm, \"\")\n    ),\n    table = jsonResponse.table;\n\n  // Extract column headers\n  const headers = table.cols.map((col: any) => col.label);\n\n  // Map rows to proper GQueryRow format\n  const rows = table.rows.map((row: any, _rowIndex: number) => {\n    const rowObj: GQueryRow = {\n      __meta: {\n        rowNum: -1, // +2 because we're starting from index 0 and row 1 is headers\n        colLength: row.c.length,\n      },\n    };\n\n    // Initialize all header fields to empty strings\n    headers.forEach((header: string) => {\n      rowObj[header] = \"\";\n    });\n\n    // Populate row data\n    table.cols.forEach((col: any, colIndex: number) => {\n      const cellData = row.c[colIndex];\n      if (cellData) {\n        // Use formatted value if available, otherwise use raw value\n        let value =\n          cellData.f !== null && cellData.f !== undefined\n            ? cellData.f\n            : cellData.v;\n\n        // Convert known data types\n        if (value instanceof Date) {\n          // Keep as Date object\n        } else if (typeof value === \"string\") {\n          // Try to auto-detect date strings\n          if (\n            /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}(\\s\\d{1,2}:\\d{1,2}(:\\d{1,2})?)?$/.test(\n              value\n            )\n          ) {\n            try {\n              const dateValue = new Date(value);\n              if (!isNaN(dateValue.getTime())) {\n                value = dateValue;\n              }\n            } catch (e) {\n              // Keep as string if conversion fails\n            }\n          }\n        }\n\n        rowObj[col.label] = value;\n      }\n    });\n\n    return rowObj;\n  });\n\n  // Return in the standard GQueryResult format\n  return {\n    headers: headers,\n    rows: rows,\n  };\n}\n","import { GQueryTableFactory } from \"./index\";\nimport { callHandler } from \"./ratelimit\";\nimport { GQueryResult, GQueryRow } from \"./types\";\n\nexport function updateInternal(\n  gQueryTableFactory: GQueryTableFactory,\n  updateFn: (row: Record<string, any>) => Record<string, any>\n): GQueryResult {\n  // Get table configuration\n  const spreadsheetId = gQueryTableFactory.gQueryTable.spreadsheetId;\n  const sheetName = gQueryTableFactory.gQueryTable.sheetName;\n  const range = sheetName;\n\n  // Fetch current data from the sheet\n  const response = callHandler(() =>\n    Sheets.Spreadsheets.Values.get(spreadsheetId, range)\n  );\n  const values = response.values || [];\n\n  if (values.length === 0) {\n    return { rows: [], headers: [] };\n  }\n\n  // Extract headers and rows\n  const headers = values[0];\n  const rows = values.slice(1).map((row) => {\n    const obj: Record<string, any> = {};\n    headers.forEach((header: string, i: number) => {\n      // Ensure all properties are initialized, even if empty\n      obj[header] = row[i] !== undefined ? row[i] : \"\";\n    });\n    return obj;\n  });\n\n  // Filter rows if where function is provided\n  let filteredRows = [];\n  if (gQueryTableFactory.filterOption) {\n    try {\n      filteredRows = rows.filter((row) => {\n        try {\n          return gQueryTableFactory.filterOption(row);\n        } catch (error) {\n          console.error(\"Error filtering row:\", error);\n          return false;\n        }\n      });\n    } catch (error) {\n      console.error(\"Error in filter function:\", error);\n      return { rows: [], headers };\n    }\n  } else {\n    filteredRows = rows;\n  }\n\n  // Update filtered rows\n  const updatedRows = filteredRows.map((row) => {\n    // Apply the update function to get the updated row values\n    const updatedRow = { ...row };\n    try {\n      const result = updateFn(updatedRow);\n      // Handle both return value updates and direct modifications\n      Object.assign(updatedRow, result);\n    } catch (error) {\n      console.error(\"Error updating row:\", error);\n    }\n\n    // Find the index of this row in the original data array\n    const rowIndex = rows.findIndex((origRow) =>\n      Object.keys(origRow).every((key) => origRow[key] === row[key])\n    );\n\n    // Add __meta to each row with required properties\n    if (rowIndex !== -1) {\n      updatedRow.__meta = {\n        rowNum: rowIndex + 2, // +2 because we have headers at index 0 and row index is 0-based\n        colLength: headers.length,\n      };\n    }\n\n    return updatedRow;\n  });\n\n  // Track changes to optimize updates\n  const changedCells = new Map<string, any[]>();\n\n  // For each updated row, determine which cells changed\n  updatedRows.forEach((updatedRow) => {\n    if (!updatedRow.__meta) return;\n\n    const rowIndex = updatedRow.__meta.rowNum - 2;\n    const originalRow = rows[rowIndex];\n\n    headers.forEach((header, columnIndex) => {\n      let updatedValue = updatedRow[header];\n\n      // Convert Date objects to strings for comparison and storage\n      if (updatedValue instanceof Date) {\n        updatedValue = updatedValue.toLocaleString();\n      }\n\n      // Skip if values are the same\n      if (originalRow[header] === updatedValue) return;\n\n      // Only update if we have a meaningful value or if the original was empty\n      // This prevents overwriting existing data with empty values\n      if (\n        updatedValue !== undefined &&\n        updatedValue !== null &&\n        updatedValue !== \"\"\n      ) {\n        // Use A1 notation for the column (A, B, C, etc.)\n        const columnLetter = getColumnLetter(columnIndex);\n        const cellRange = `${sheetName}!${columnLetter}${updatedRow.__meta.rowNum}`;\n\n        // Store the change\n        changedCells.set(cellRange, [[updatedValue]]);\n      } else if (\n        originalRow[header] === \"\" ||\n        originalRow[header] === undefined ||\n        originalRow[header] === null\n      ) {\n        // Only clear the cell if the original was already empty and we explicitly want to set it to empty\n        const columnLetter = getColumnLetter(columnIndex);\n        const cellRange = `${sheetName}!${columnLetter}${updatedRow.__meta.rowNum}`;\n        changedCells.set(cellRange, [[updatedValue || \"\"]]);\n      }\n      // If updatedValue is empty but original had content, we skip the update to preserve existing data\n    });\n  });\n\n  // Only update if we have changes\n  if (changedCells.size > 0) {\n    // Group adjacent cells in the same column for more efficient updates\n    const optimizedUpdates = optimizeRanges(changedCells);\n\n    // Create a batch update request\n    const batchUpdateRequest = {\n      data: [],\n      valueInputOption: \"USER_ENTERED\",\n    };\n\n    // Add each range to the batch request\n    for (const [range, values] of Object.entries(optimizedUpdates)) {\n      batchUpdateRequest.data.push({\n        range: range,\n        values: values,\n      });\n    }\n\n    // Send a single batch update to Google Sheets\n    callHandler(() =>\n      Sheets.Spreadsheets.Values.batchUpdate(batchUpdateRequest, spreadsheetId)\n    );\n  }\n\n  // If updates were made, properly return the filtered and updated rows\n  // Make a fresh copy of the returned rows to ensure they have proper structure\n  const resultRows =\n    filteredRows.length > 0\n      ? updatedRows.map((row) => {\n          const resultRow: GQueryRow = { __meta: row.__meta };\n          headers.forEach((header) => {\n            resultRow[header] = row[header];\n          });\n          return resultRow;\n        })\n      : [];\n\n  // Return the updated rows\n  return {\n    rows: resultRows as GQueryRow[],\n    headers: headers,\n  };\n}\n\n/**\n * Convert column index to column letter (0 -> A, 1 -> B, etc.)\n */\nfunction getColumnLetter(columnIndex: number): string {\n  let columnLetter = \"\";\n  let index = columnIndex;\n\n  while (index >= 0) {\n    columnLetter = String.fromCharCode(65 + (index % 26)) + columnLetter;\n    index = Math.floor(index / 26) - 1;\n  }\n\n  return columnLetter;\n}\n\n/**\n * Optimize update ranges by combining adjacent cells in the same column\n */\nfunction optimizeRanges(changedCells: Map<string, any[]>): {\n  [range: string]: any[][];\n} {\n  // Group cells by column\n  const columnGroups = new Map<string, Map<number, any>>();\n\n  for (const [cellRange, value] of changedCells.entries()) {\n    // Extract column letter and row number from A1 notation\n    const matches = cellRange.match(/([^!]+)!([A-Z]+)(\\d+)$/);\n    if (!matches) continue;\n\n    const sheet = matches[1];\n    const columnLetter = matches[2];\n    const rowNumber = parseInt(matches[3]);\n    const columnKey = `${sheet}!${columnLetter}`;\n\n    if (!columnGroups.has(columnKey)) {\n      columnGroups.set(columnKey, new Map());\n    }\n\n    columnGroups.get(columnKey).set(rowNumber, value[0][0]);\n  }\n\n  // Create optimized ranges\n  const optimizedUpdates: { [range: string]: any[][] } = {};\n\n  for (const [columnKey, rowsMap] of columnGroups.entries()) {\n    // Sort row numbers\n    const rowNumbers = Array.from(rowsMap.keys()).sort((a, b) => a - b);\n\n    if (rowNumbers.length === 0) continue;\n\n    // Find min and max to create one range per column\n    const minRow = Math.min(...rowNumbers);\n    const maxRow = Math.max(...rowNumbers);\n\n    // Extract sheet name and column from columnKey\n    const sheet = columnKey.split(\"!\")[0];\n    const column = columnKey.split(\"!\")[1];\n\n    // Create a single range from min to max row\n    const rangeKey = `${sheet}!${column}${minRow}:${column}${maxRow}`;\n\n    // Create array of values with proper ordering\n    const values = [];\n    for (let row = minRow; row <= maxRow; row++) {\n      // Use the updated value if it exists, otherwise use empty string to preserve the existing value\n      let value = rowsMap.has(row) ? rowsMap.get(row) : \"\";\n\n      // Convert Date objects to strings\n      if (value instanceof Date) {\n        value = value.toLocaleString();\n      }\n\n      values.push([value]);\n    }\n\n    optimizedUpdates[rangeKey] = values;\n  }\n\n  return optimizedUpdates;\n}\n","import { GQueryTable } from \"./index\";\nimport { callHandler } from \"./ratelimit\";\nimport { GQueryResult, GQueryRow } from \"./types\";\n\nexport function appendInternal(\n  table: GQueryTable,\n  data: { [key: string]: any }[]\n): GQueryResult {\n  // If no data is provided or empty array, return empty result\n  if (!data || data.length === 0) {\n    return { rows: [], headers: [] };\n  }\n\n  // Extract spreadsheet information\n  const spreadsheetId = table.spreadsheetId;\n  const sheetName = table.sheetName;\n\n  // First, get the current headers from the sheet\n  const response = callHandler(() =>\n    Sheets.Spreadsheets.Values.get(spreadsheetId, `${sheetName}!1:1`)\n  );\n\n  // If sheet is empty or doesn't exist, cannot append\n  if (!response || !response.values || response.values.length === 0) {\n    throw new Error(`Sheet \"${sheetName}\" not found or has no headers`);\n  }\n\n  const headers = response.values[0].map((header) => String(header));\n\n  // Format data to be appended according to the sheet's headers\n  const rowsToAppend = data.map((item) => {\n    // For each header, get corresponding value from item or empty string\n    return headers.map((header) => {\n      let value = item[header];\n\n      // Convert Date objects to strings\n      if (value instanceof Date) {\n        value = value.toLocaleString();\n      }\n\n      return value !== undefined ? value : \"\";\n    });\n  });\n\n  // Use Sheets API to append the data\n  const appendResponse = callHandler(() =>\n    Sheets.Spreadsheets.Values.append(\n      { values: rowsToAppend },\n      spreadsheetId,\n      `${sheetName}`,\n      {\n        valueInputOption: \"USER_ENTERED\",\n        insertDataOption: \"OVERWRITE\",\n        responseValueRenderOption: \"FORMATTED_VALUE\",\n        responseDateTimeRenderOption: \"FORMATTED_STRING\",\n        includeValuesInResponse: true,\n      }\n    )\n  );\n\n  // Check if append was successful\n  if (\n    !appendResponse ||\n    !appendResponse.updates ||\n    !appendResponse.updates.updatedRange\n  ) {\n    throw new Error(\"Failed to append data to sheet\");\n  }\n\n  // Extract information about the appended rows\n  const updatedRange = appendResponse.updates.updatedRange;\n  const rangeMatch = updatedRange.match(/([^!]+)!([A-Z]+)(\\d+):([A-Z]+)(\\d+)/);\n\n  if (!rangeMatch) {\n    throw new Error(`Could not parse updated range: ${updatedRange}`);\n  }\n\n  // Get start and end row numbers from the updated range\n  const startRow = parseInt(rangeMatch[3]);\n  const endRow = parseInt(rangeMatch[5]);\n\n  // Create result rows with metadata\n  const resultRows: GQueryRow[] = rowsToAppend.map((row, index) => {\n    const rowObj: GQueryRow = {\n      __meta: {\n        rowNum: startRow + index,\n        colLength: headers.length,\n      },\n    };\n\n    // Add data according to headers\n    headers.forEach((header, colIndex) => {\n      rowObj[header] = row[colIndex];\n    });\n\n    return rowObj;\n  });\n\n  return {\n    rows: resultRows,\n    headers: headers,\n  };\n}\n","import { GQueryTableFactory } from \"./index\";\nimport { callHandler } from \"./ratelimit\";\n\nexport function deleteInternal(gqueryTableFactory: GQueryTableFactory): {\n  deletedRows: number;\n} {\n  // Get table configuration\n  const spreadsheetId = gqueryTableFactory.gQueryTable.spreadsheetId;\n  const sheetName = gqueryTableFactory.gQueryTable.sheetName;\n  const sheet = gqueryTableFactory.gQueryTable.sheet;\n  const sheetId = sheet.getSheetId();\n\n  // Fetch current data from the sheet\n  const response = callHandler(() =>\n    Sheets.Spreadsheets.Values.get(spreadsheetId, sheetName)\n  );\n  const values = response.values || [];\n\n  if (values.length <= 1) {\n    // Only header row or empty sheet\n    return { deletedRows: 0 };\n  }\n\n  // Extract headers and rows\n  const headers = values[0];\n  const rows: Record<string, any>[] = values.slice(1).map((row, rowIndex) => {\n    const obj: Record<string, any> = {\n      __meta: {\n        rowNum: rowIndex + 2, // +2 because we're starting from index 0 and row 1 is headers\n        colLength: row.length,\n      },\n    };\n\n    headers.forEach((header: string, i: number) => {\n      obj[header] = i < row.length ? row[i] : \"\";\n    });\n\n    return obj;\n  });\n\n  // If no filter option, nothing to delete\n  if (!gqueryTableFactory.filterOption || rows.length === 0) {\n    return { deletedRows: 0 };\n  }\n\n  // Find rows matching the filter condition (these will be deleted)\n  const rowsToDelete = rows.filter((row) => {\n    try {\n      return gqueryTableFactory.filterOption(row);\n    } catch (error) {\n      console.error(\"Error filtering row:\", error);\n      return false;\n    }\n  });\n\n  if (rowsToDelete.length === 0) {\n    return { deletedRows: 0 };\n  }\n\n  // Sort rowsToDelete by row number in descending order to avoid shifting issues\n  rowsToDelete.sort((a, b) => b.__meta.rowNum - a.__meta.rowNum);\n\n  // Create an array of row indices to delete\n  const rowIndicesToDelete = rowsToDelete.map((row) => row.__meta.rowNum);\n\n  // Create batch update request for deleting the rows\n  const batchUpdateRequest = {\n    requests: rowIndicesToDelete.map((rowIndex) => ({\n      deleteDimension: {\n        range: {\n          sheetId: sheetId,\n          dimension: \"ROWS\",\n          startIndex: rowIndex - 1, // Convert to 0-based index\n          endIndex: rowIndex, // Range is end-exclusive\n        },\n      },\n    })),\n  };\n\n  // Execute the batch update\n  try {\n    callHandler(() =>\n      Sheets.Spreadsheets.batchUpdate(batchUpdateRequest, spreadsheetId)\n    );\n  } catch (error) {\n    console.error(\"Error deleting rows:\", error);\n    return { deletedRows: 0 };\n  }\n\n  return { deletedRows: rowsToDelete.length };\n}\n","import { getInternal, getManyInternal, queryInternal } from \"./get\";\nimport { updateInternal } from \"./update\";\nimport { appendInternal } from \"./append\";\nimport { deleteInternal } from \"./delete\";\nimport { GQueryReadOptions, GQueryResult } from \"./types\";\n\nexport * from \"./types\";\n\nexport class GQuery {\n  spreadsheetId: string;\n\n  constructor(spreadsheetId?: string) {\n    this.spreadsheetId = spreadsheetId\n      ? spreadsheetId\n      : SpreadsheetApp.getActiveSpreadsheet().getId();\n  }\n\n  from(sheetName: string): GQueryTable {\n    return new GQueryTable(this, this.spreadsheetId, sheetName);\n  }\n\n  getMany(\n    sheetNames: string[],\n    options?: GQueryReadOptions\n  ): {\n    [sheetName: string]: GQueryResult;\n  } {\n    return getManyInternal(this, sheetNames, options);\n  }\n}\n\nexport class GQueryTable {\n  gquery: GQuery;\n  spreadsheetId: string;\n  spreadsheet: GoogleAppsScript.Spreadsheet.Spreadsheet;\n  sheetName: string;\n  sheet: GoogleAppsScript.Spreadsheet.Sheet;\n\n  constructor(gquery: GQuery, spreadsheetId: string, sheetName: string) {\n    this.spreadsheetId = spreadsheetId;\n    this.sheetName = sheetName;\n    this.spreadsheet = SpreadsheetApp.openById(spreadsheetId);\n    this.sheet = this.spreadsheet.getSheetByName(sheetName);\n    this.gquery = gquery;\n  }\n\n  select(headers: string[]): GQueryTableFactory {\n    return new GQueryTableFactory(this).select(headers);\n  }\n\n  where(filterFn: (row: any) => boolean): GQueryTableFactory {\n    return new GQueryTableFactory(this).where(filterFn);\n  }\n\n  join(\n    sheetName: string,\n    sheetColumn: string,\n    joinColumn: string,\n    columnsToReturn?: string[]\n  ): GQueryTableFactory {\n    return new GQueryTableFactory(this).join(\n      sheetName,\n      sheetColumn,\n      joinColumn,\n      columnsToReturn\n    );\n  }\n\n  update(\n    updateFn: (row: Record<string, any>) => Record<string, any>\n  ): GQueryResult {\n    return new GQueryTableFactory(this).update(updateFn);\n  }\n\n  append(\n    data: { [key: string]: any }[] | { [key: string]: any }\n  ): GQueryResult {\n    // Handle single object by wrapping it in an array\n    const dataArray = Array.isArray(data) ? data : [data];\n    return appendInternal(this, dataArray);\n  }\n\n  get(options?: GQueryReadOptions): GQueryResult {\n    return new GQueryTableFactory(this).get(options);\n  }\n\n  query(query: string): GQueryResult {\n    return queryInternal(this, query);\n  }\n\n  delete(): { deletedRows: number } {\n    return new GQueryTableFactory(this).delete();\n  }\n}\n\nexport class GQueryTableFactory {\n  gQueryTable: GQueryTable;\n  selectOption?: string[];\n  filterOption?: (row: any) => boolean;\n  joinOption: {\n    sheetName: string;\n    sheetColumn: string;\n    joinColumn: string;\n    columnsToReturn?: string[];\n  }[] = [];\n\n  constructor(GQueryTable: GQueryTable) {\n    this.gQueryTable = GQueryTable;\n  }\n\n  select(headers: string[]): GQueryTableFactory {\n    this.selectOption = headers;\n    return this;\n  }\n\n  where(filterFn: (row: any) => boolean): GQueryTableFactory {\n    this.filterOption = filterFn;\n    return this;\n  }\n\n  join(\n    sheetName: string,\n    sheetColumn: string,\n    joinColumn: string,\n    columnsToReturn?: string[]\n  ): GQueryTableFactory {\n    this.joinOption.push({\n      sheetName,\n      sheetColumn,\n      joinColumn,\n      columnsToReturn,\n    });\n    return this;\n  }\n\n  get(options?: GQueryReadOptions): GQueryResult {\n    return getInternal(this, options);\n  }\n\n  update(\n    updateFn: (row: Record<string, any>) => Record<string, any>\n  ): GQueryResult {\n    return updateInternal(this, updateFn);\n  }\n\n  append(\n    data: { [key: string]: any }[] | { [key: string]: any }\n  ): GQueryResult {\n    // Handle single object by wrapping it in an array\n    const dataArray = Array.isArray(data) ? data : [data];\n    return appendInternal(this.gQueryTable, dataArray);\n  }\n\n  delete(): { deletedRows: number } {\n    return deleteInternal(this);\n  }\n}\n"],"names":["ValueRenderOption","DateTimeRenderOption"],"mappings":"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"}